////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//  THIS IS NOT A COMPLICATED ANTICHEAT PLUGIN.                                   //
//  PEOPLE SMARTER THAN ME HAVE WRITTEN THOSE.                                    //
//                                                                                //
//  SEE HERE: -> https://github.com/Silenci0/SMAC                                 //
//  OR HERE:  -> https://forums.alliedmods.net/showthread.php?t=321480            //
//                                                                                //
//  If someone is using an actual cheat, like nullcore or lithium or lmaobox,     //
//  this plugin will likely do nothing at all. This is merely to prevent          //
//  otherwise vanilla players from cheating with easily exploitable methods.      //
//                                                                                //
//                                                                                //
//  Currently prevents:                                                           //
//   -> interp abuse               (checks cl_interp above .1, instakick)         //
//   -> (hopefully) box shadows    (checks a series of convars, instakick)        //
//   -> clients using turn binds   (WARNS CLIENT, then kicks after 3 violations)  //
//   -> client ping >= 200         (WARNS CLIENT, then kicks after 3 violations)  //
//   -> client packet loss >= 30%  (WARNS CLIENT, then kicks after 3 violations)  //
//                                                                                //
//  Currently notifies to console of:                                             //
//   -> cmdrate pingmasking (if cmdrate is > 60 or has nonnumerical chars)        //
//                                                                                //
//  Todo (may not be possible):                                                   //
//   -> fix spy decloak exploit / other soundscript exploits                      //
//   -> fix other sv pure stuff (flat / invisible textures)                       //
//   -> fix sniper scope removal exploit                                          //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

#pragma semicolon 1

#include <sourcemod>
#include <color_literals>
#include <regex>
#include <entity_prop_stocks>
#include <sdktools>
#undef REQUIRE_PLUGIN
#include <soap_tournament>
#include <updater>

#define PLUGIN_VERSION "2.0.2"
#define UPDATE_URL "https://raw.githubusercontent.com/stephanieLGBT/tf2-stopexploits/master/updatefile.txt"
public Plugin myinfo =
{
    name             =  "Basic Exploit Prevention",
    author           =  "stephanie",
    description      =  "Prevents some common exploits in TF2 (orig. forked from IntegriTF2)",
    version          =   PLUGIN_VERSION,
    url              =  "https://steph.anie.dev/"
}

Handle:g_hSetHookSpawn;
Handle:findSOAP;
Handle:findMGE;
bool:hookSpawn = true;
turnTimes[MAXPLAYERS+1];
pingViolated[MAXPLAYERS+1];
lossViolated[MAXPLAYERS+1];
Float:violPingAvg[MAXPLAYERS+1];
Float:violLossAvg[MAXPLAYERS+1];
Float:tickinterv;

maxPingViolAmt = 3;
maxLossViolAmt = 3;

maxPingAllowed = 200;
maxLossAllowed = 30;

Float:maxAllowedTurnSecs = 1.0;
public OnPluginStart()
{
    checkSoapAndMGE();
    RegAdminCmd("sm_forcecheck", ForceCheck, ADMFLAG_ROOT, "Force check client convars for anticheat stuff");
    HookEvent("player_spawn", OnPlayerSpawn);
    // wait 15 secs to start checking clients after startup
    CreateTimer(15.0, Timer_CheckClientConVars);
    // get tick interval
    Float:tickinterv = GetTickInterval();
}

public OnMapStart()
{
    checkSoapAndMGE();
}

public OnLibraryAdded(const String:name[])
{
    if (StrEqual(name, "updater"))
    {
        Updater_AddPlugin(UPDATE_URL);
    }
}

checkSoapAndMGE()
{
    // -> DETECT SOAP DM AND OR MGEMOD as they both have rapid spawns that can bring a server to its knees if we hook spawns while either are active!
    Handle:findSOAP = FindPluginByFile("soap_tf2dm.smx");
    // if we can find soap...
    if (findSOAP != INVALID_HANDLE)
    {
        //...then check if it's actually running!
        if (GetPluginStatus(findSOAP) == Plugin_Running)
        {
            // if it is, DON'T hook spawns
            hookSpawn = false;
        }
    }

    Handle:findMGE = FindPluginByFile("mgemod.smx");
    // if we can find mgemod...
    if (findMGE != INVALID_HANDLE)
    {
        //...then check if it's actually running!
        if (GetPluginStatus(findMGE) == Plugin_Running)
        {
            // if it is, DON'T hook spawns
            hookSpawn = false;
        }
    }
}

public OnClientPostAdminCheck(Cl)
{
    if (IsClientInGame(Cl) && !IsFakeClient(Cl))
    {
        int userid = GetClientUserId(Cl);
        // clear all old values for netchecker and turnchecker
        turnTimes[Cl]              = 0;
        pingViolated[Cl]           = 0;
        lossViolated[Cl]           = 0;
        violPingAvg[Cl]            = 0.0;
        violLossAvg[Cl]            = 0.0;
        // query convars on player connect
        LogMessage("[BasicExploitPrevention] %N joined. Checking cvars", Cl);
        QueryEverything(userid);
    }
}

public Action ForceCheck(int client, int args)
{
    QueryEverythingAllClients();
    ReplyToCommand(client, "Forcibly checking cvars.");
}

public void SOAP_StartDeathMatching()
{
    LogMessage("soap start deathmatching hookSpawn false");
    hookSpawn = false;
    delete g_hSetHookSpawn;
}

public void SOAP_StopDeathMatching()
{
    LogMessage("soap stop deathmatching");
    // wait 7.5 seconds to start hooking spawns for cvar checking
    // (avoids hooking first spawns when tournament starts but avoids a race condition with soap spawning people and immediately querying convars)
    delete g_hSetHookSpawn;
    g_hSetHookSpawn = CreateTimer(7.5, setHookSpawn, TIMER_FLAG_NO_MAPCHANGE);
}

public Action setHookSpawn(Handle timer)
{
    LogMessage("hookSpawn true");
    // this is needed to prevent the above race condition
    QueryEverythingAllClients();
    hookSpawn = true;
    g_hSetHookSpawn = null;
}

public Action OnPlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
    if (hookSpawn)
    {
        int userid = GetEventInt(Handle:event, "userid");
        int Cl = GetClientOfUserId(userid);
        LogMessage("[BasicExploitPrevention] %N spawned. checking cvars", Cl);
        QueryEverything(userid);
    }
}

checkNetSettings(userid)
{
    // get the right client index here
    int Cl = GetClientOfUserId(userid);
    // this makes sure we don't query net settings immediately on client join because they aren't accurate anyway
    if (GetClientTime(Cl) <= 60)
    {
        return;
    }
    // latency in ms
    float avgPingNOW    = GetClientLatency(Cl, NetFlow_Both) * 1000;
    // loss amt as a percentage
    float avgLossNOW    = GetClientAvgLoss(Cl, NetFlow_Both) * 100;
    // is ping higher than allowed?
    if (avgPingNOW >= maxPingAllowed)
    {
        if (pingViolated[Cl] < maxPingViolAmt)
        {
            PrintColoredChat(Cl, COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Your ping (%f ms) is unreasonably high! Fix your internet or you could be autokicked!", avgPingNOW);
            violPingAvg[Cl] = avgPingNOW + violPingAvg[Cl];
            pingViolated[Cl]++;
        }
        else if (pingViolated[Cl] >= maxPingViolAmt)
        {
            violPingAvg[Cl] = (violPingAvg[Cl] / maxPingViolAmt);
            KickClient(Cl, "Your ping was above the allowed value (your ping in ms: %f. max: 200) for too long. Autokicked", violPingAvg[Cl]);
            LogMessage("Player %N had consistent ping (avg in ms: %f) above 200 for too long. Kicked from server", Cl, violPingAvg[Cl]);
            PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N had consistent ping above 200" ... COLOR_MEDIUMPURPLE ... "(avg in ms: %f)" ... COLOR_WHITE ... " for too long." ... COLOR_PALEGREEN ... "Kicked from server.", Cl, violPingAvg[Cl]);
        }
    }
    else if (avgPingNOW < 200.0)
    {
        if (pingViolated[Cl] >= 1)
        {
            violPingAvg[Cl] = 0.0;
            pingViolated[Cl]--;
        }
    }
    if (avgLossNOW >= maxLossAllowed)
    {
        if (lossViolated[Cl] < maxLossViolAmt)
        {
            PrintColoredChat(Cl, COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Your packet loss (currently %f%%) is unreasonably high! Fix your internet or you could be autokicked!", avgLossNOW);
            violLossAvg[Cl] = avgLossNOW + violLossAvg[Cl];
            lossViolated[Cl]++;
        }

        if (lossViolated[Cl] >= maxLossViolAmt)
        {
            violLossAvg[Cl] = (violLossAvg[Cl] / maxLossViolAmt);
            KickClient(Cl, "Your packet loss was above 30%% (avg: %f%%) for too long. Autokicked", violLossAvg[Cl]);
            LogMessage("Player %N had consistent packet loss (avg: %f%%) above 50%% for too long. Kicked from server", Cl, violLossAvg[Cl]);
            PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N had consistent packet above 50%% " ... COLOR_MEDIUMPURPLE ... "(avg: %f%%)" ... COLOR_WHITE ... " for too long." ... COLOR_PALEGREEN ... "Kicked from server.", Cl, violLossAvg[Cl]);
        }
    }
    else if (avgLossNOW < 30.0)
    {
        if (lossViolated[Cl] >= 1)
        {
            violLossAvg[Cl] = 0.0;
            lossViolated[Cl]--;
        }
    }
}

public Action OnPlayerRunCmd(
    int client,
    int& buttons,
    int& impulse,
    float vel[3],
    float angles[3],
    int& weapon,
    int& subtype,
    int& cmdnum,
    int& tickcount,
    int& seed,
    int mouse[2]
    )
{
    if (buttons & IN_LEFT || buttons & IN_RIGHT)
    {
        turnTimes[client]++;
        float turnSec = turnTimes[client] * tickinterv;
        LogMessage("detected turn bind on player [%L] for [%f] seconds", client, turnSec);
        if (turnSec < maxAllowedTurnSecs)
        {
            PrintColoredChat(client, COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Turn binds and spin binds are not allowed on this server. If you continue to use them you will be autokicked!");
        }
        else if (turnSec > maxAllowedTurnSecs)
        {
            KickClient(client, "Usage of turn binds or spin binds is not allowed. Autokicked");
            LogMessage("[BasicExploitPrevention] Player %N was using turn binds! Kicked from server.", client);
            PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N was using turn binds! " ... COLOR_PALEGREEN ... "Kicked from server.", client);
        }
    }
}


public ConVarCheck(QueryCookie cookie, int Cl, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (Cl == 0 || !IsClientInGame(Cl) || result != ConVarQuery_Okay)
    {
        return;
    }
    // cl_interp
    if (StrEqual(cvarName, "cl_interp"))
    {
        // cl_interp needs to be at or BELOW tf2's default settings
        if (StringToFloat(cvarValue) > 0.100000)
        {
            KickClient(Cl, "CVar %s = %s, outside reasonable bounds. Change it to .1 at most", cvarName, cvarValue);
            LogMessage("[BasicExploitPrevention] Player %N was using CVar %s = %s, indicating interp explotation. Kicked from server.", Cl, cvarName, cvarValue);
            PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N was using CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ..." = " ... COLOR_MEDIUMPURPLE ... "%s"  ... COLOR_WHITE ... ", indicating interp explotation." ... COLOR_PALEGREEN ... "Kicked from server.", Cl, cvarName, cvarValue);
        }
    }
    // cl_cmdrate
    else if (StrEqual(cvarName, "cl_cmdrate"))
    {
        if (!cvarValue[0])
        {
            LogMessage("[BasicExploitPrevention] Null string returned as cvar result!");
        }
        // cl_cmdrate needs to be above 60 AND not have any non numerical chars (xcept the . sign if its a float) in it because otherwise player ping gets messed up on the scoreboard
        else if ((StringToFloat(cvarValue) < 60) || SimpleRegexMatch(cvarValue, "^\\d*\\.?\\d*$") <= 0)
        {
            LogMessage("[BasicExploitPrevention] Player %N is using CVar %s = %s, possibly ping-masking or rate exploiting!", Cl, cvarName, cvarValue);
        }
    }
    // r_shadows
    else if (StrEqual(cvarName, "r_shadows"))
    {
        if (StringToInt(cvarValue) != 0)
        {
            QueryClientConVar(Cl, "cl_blobbyshadows", ConVarQueryFinished:ConVarCheck);
        }
    }
    // cl_blobbyshadows
    else if (StrEqual(cvarName, "cl_blobbyshadows"))
    {
        if (StringToInt(cvarValue) != 0)
        {
            QueryClientConVar(Cl, "r_shadowrendertotexture", ConVarQueryFinished:ConVarCheck);
        }
    }
    // r_shadowrendertotexture
    else if (StrEqual(cvarName, "r_shadowrendertotexture"))
    {
        if (StringToInt(cvarValue) != 0)
        {
            QueryClientConVar(Cl, "r_shadowmaxrendered ", ConVarQueryFinished:ConVarCheck);
        }
    }
    // r_shadowmaxrendered
    else if (StrEqual(cvarName, "r_shadowmaxrendered"))
    {
        if (StringToInt(cvarValue) >= 12)
        {
            KickClient(Cl, "Player %N was using box shadows!", Cl);
            PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N was using BOX SHADOWS! " ... COLOR_PALEGREEN ... "Kicked from server.", Cl);
            LogMessage("[BasicExploitPrevention] Player %N was using box shadows!", Cl);
        }
    }
}

QueryEverything(int userid)
{
    int Cl = GetClientOfUserId(userid);
    if (IsClientInGame(Cl) && !IsFakeClient(Cl))
    {
        // convars to check
        QueryClientConVar(Cl, "cl_interp", ConVarQueryFinished:ConVarCheck);
        QueryClientConVar(Cl, "cl_cmdrate", ConVarQueryFinished:ConVarCheck);
        // querying r_shadows starts a chain of querying other shadow related cvars to check for box shadows
        QueryClientConVar(Cl, "r_shadows", ConVarQueryFinished:ConVarCheck);
    }
}

QueryEverythingAllClients()
{
    LogMessage("[BasicExploitPrevention] Querying all clients");
    for (int Cl = 1; Cl <= MaxClients; Cl++)
    {
        if (IsClientInGame(Cl) && !IsFakeClient(Cl))
        {
            int userid = GetClientUserId(Cl);
            QueryEverything(userid);
            checkNetSettings(userid);
        }
    }
}

public Action Timer_CheckClientConVars(Handle:timer)
{
    // iterate thru clients
    QueryEverythingAllClients();
    // check randomly (every 1 - 5 minutes) for violating players, then recheck with a new random value
    CreateTimer(GetRandomFloat(60.0, 300.0), Timer_CheckClientConVars);
}
